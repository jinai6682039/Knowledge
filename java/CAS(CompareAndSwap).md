# CAS（Compare and Swap）无锁算法与非阻塞同步算法

## Lock的使用代价
锁使用来解决并发问题的最简单无脑的方式，但其造成的代价也是非常高。内核态的锁进行操作时，需要进行**系统上下文切换**。而进行**加锁和释放锁**的时候，也会发生较多的**上下文切**换以及**线程（进程）调度**，等待锁的线程将会被**挂起**，直到锁被释放。同时在进行相同上下文切换时，cpu之前执行的线程所使用的**寄存器以及高速缓存**中的数据都将**失效**。与此同时，当一个**拥有锁的线程被延迟执行**，那么所有等待锁的其他线程都将被**挂起**，无法继续执行。如果**等待锁**的线程**优先级高**，而**持有锁**的线程**优先级低**，还会导致**优先级反转**。Java中的synchronzied锁使用的锁就是这种独占锁（悲观锁）。

## 乐观锁与悲观锁（独占锁）
悲观锁：假设最坏情况，每次执行的时候都当作有其他线程与其竞争，保证当前线程的执行绝对不会被其他线程干扰下才进行执行，其他等待锁的线程将会被挂起。
乐观锁：每次线程操作假设在进行操作时没有发生冲突，在执行完成后再判断是否发生了冲突。若存在冲突，则重复执行，直到没有发生冲突为止。

## volatile
Java也提供了一种比锁更轻量级的同步操作：volatile。此修饰符修饰的表里不会发生上下文切换和线程调度，而是再对这些变量进行读取之前加上一个内存屏障，再修改了这些变量之后加上一个内存屏障。这个修饰符只能保证可见性，并不能 保证原子性。

## CAS无锁算法
CAS的具体语法为：当前我认为变量V的值应该为A，如果此时V的值为A，那么将V的值修改为B，若不是，则告知我现在V的实际值。这里采用的就是乐观锁的概念，在多个线程对同一个变量进行操作时，只有一个线程能够更新变量的值，而其他的线程都将失败，但失败的线程不会被挂起，而时可以继续尝试更新。CAS有三个操作数：内存值V、旧的预期值A、新的需要修改的值B。当且仅当V的值为A时，才会将V的值修改为B。

CAS由于其是一条CPU指令操作，只有一步原子操作，速度非常快。但其还是存在一定开销在用来寻找最后一个对变量进行修改的CPU上所修改的变量最新值。

## Java对CAS的支持
在Java的原子类变量中，java.util.concurrent.atomic包中的AtomicXXX，都支持了JVM支持的CAS操作，这里一般是调用Unsafe类中的CAS算法。