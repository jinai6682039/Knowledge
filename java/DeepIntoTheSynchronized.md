# Deep into the synchronized

## 由线程安全开始
线程安全是并发编程中的至关重要的一点。造成线程安全的有两种前提：
1、存在共享资源
2、存在多个线程同时操作共享资源
为了线程安全，我们需要确保同一时刻只能有一个线程对共享资源进行操作，其他线程必须在等待当前线程处理完后才能进行处理。这个也是悲观锁（互斥锁）的概念。Java提供了synchronized关键字，来保证上面所说的线程安全，保证了同一时刻只有一个线程执行某个方法或者某个代码块。同时，synchronized还可以保证可见性，也就是线程的操作可以被其他线程所看到，从某些地方可以代替volatile，并同时保证原子性与可见性。

## synchronized的用法
synchronized可以用来修饰静态方法、实例方法和代码块。
修饰静态方法，对当前类对象进行加锁，进入同步方法前需要获取当前类对象的锁。
修饰实例方法，对当前实例对象进行加锁，进入同步方法前需要获取当前实例对象的锁。
修饰代码块，需要指明加锁的对象，给指定的对象进行加锁，进入同步方法前需要获取给定对象的锁。

## synchronized的底层实现
synchronized的底层实现涉及到JVM中对对象的存储结构，其是基于对monitor对象的进入和退出的实现，分有显示同步（修饰代码块，指明同步对象）和隐式同步（修饰方法）两种。前者是通过monitorenter和monitorexit来实现的。后者是根据方法的标志位中是否含有ACC_SYNCHRONIZED来实现的。

在JVM中，存储的对象在内存中分为三部分：**对象头、实例变量、填充数据**。
实例变量中存储的是类的属性基本信息，按四字节对齐。填充数据是由于虚拟机对对象起始地址必须是八字节的整数倍，是为了对齐八字节而存在的。
对象头就涉及到synchronized的重点，通常情况下**对象头**可以用**两**个字存储，但如果**是数组对象**，则会用**三**个字，**第三个字位数组的长度**。其前两个字分别为**MARK WORD以及CLASS METADATA ADDRESS**。
CLASS METADATA ADDRESS：用来确定类元信息，也就是这个对象是哪个class的实例。
MARK WORD：通常情况下存储这对象的**hashcode、分代年龄、锁标记位**等。但在某些情况下，对象头中还可以保存和对象锁相关的指针信息，也就是**monitor对象的起始地址**。
在JVM中，每个**对象**都会有自己**一一对应的monitor对象**，其可能随着对象的**创建而创建、销毁而销毁**或者当某个线程**试图获取**某个对象的**对象锁**时**自动生成**。当一个对象的锁被某个线程持有，此对象就处于锁定状态，直到此线程释放这个monitor对象。
在JVM中monitor都是由**ObjectMonitor**实现的，所有**等待获取monitor的线程**都会被封装成**ObjectWaiter**对象。在ObjectMonitor对象中有EntryList、WaitSet两个用来存放ObjectWaiter的队列，其次还拥有owner（用来存储当前获取此monitor的线程）、count（monitor获取计数）等字段。 
当多个线程试图争取某个**对象**的**ObjectMonitor**时，JVM会将这些**线程封装成ObjectWaiter对象**，并将其加入到此**ObjectMonitor对象的EntryList**中。在进行线程调度后，EntryList中**某个线程**获取了此**ObjectMonitor**对象，此时就会将**owner设为此线程**、**count加一操作**。直到线程调用**wait()或者执行完成**。这里首先会将**ObjectMonitor的owner、count等字段重置**，准备在EntryList中**再次寻找线程竞争ObjectMonitor对象**。此外，若是调用了**wait()**，还会将此线程加入到**waitSet**中，**等待被唤醒**。
上述已经说明了synchronized所获取的锁的来源时对象头中指明的monitor对象，这也就是为什么java中任意对象都可以当成锁来同步代码块操作。

## synchronized的底层原理

在使用synchronzied修饰**代码块**时，对应的java代码生成的字节码通常会生成**一条monitorenter指令和两条monitorexit指令**。**monitorenter**指令就是**同步代码块的开始位置**，**monitorexit**代表着**退出同步代码块的执行**。
当某个线程**试图进入同步代码块**时，首先会执行**monitorenter**这条指令。这条指令会去试图获取**指定对象的对象头中的monitor对象**，如果此时**monitor**的**count为0**，则可以成功获取**monitor**对象，在成功获取之后，会将**count加一以及将owenr设为当前线程**。若**count不为0**，则说明**其他线程**已经拥有了此对象的monitor，当前线程将会**被阻塞**，直到获取monitor的线程的**同步代码块执行完毕，调用monitorexit指令，将monitor释放**。在JVM中，无论如何都会保证每个**monitorenter指令**都会有与之**对应的monitorexit指令**，这里也就是**第二个monitorexit指令的原因**。这个monitorexit其是是放在一个**异常处理**中，出现的原因是为了若再**同步代码块中的执行抛出了异常**，会在异常抛出之前，**调用monitorexit来释放monitor对象，是其他线程可以继续竞争monitor锁**。

再使用synchronized修饰方法（**实例方法与静态方法**）时，获取的对象锁的来源分别来源于**实例对象以及类对象**。此时在字节码中**不会出现monitorenter与monitorexit指令**，取而代之的是使用的时方法的flag中的**ACC_SYNCHRONIZED**标志位。当一个方法被**synchronized**修饰时，在编译器进行编译的时候，会将此方法在**常量池**中的对应**方法结构表的flags**加上**ACC_SYNCHRONIZED**标志位，此时这个方法就是**同步方法**了。在某个线程在执行某个方法时，若发现这个**方法结构表的flags**中有**ACC_SYNCHRONIZED**标志位，则会去获取对应的对象的**monitor锁**，在获取了monitor锁后才回去继续执行方法。若此时其他线程占有了此对象的monitor对象，这个线程将会被**阻塞**，直到**获取monitor的线程执行完同步方法**。若一个同步方法在执行时，发生了异常，但又无法进行异常捕获处理，则此同步方法将会在此**异常被抛到方法外之前将monitor释放**。

## Java对synchronized的优化
在Java中，synchronized使用的**monitor锁对象**其实是一个**重量级锁**，其依赖于操作系统底层的**mutex lock互斥锁**来实现的。操作系统进行线程切换时会涉及到较多的**系统上下文切换**和**用户态到核心态的转化**，这个过程是非常耗时的，这也就是为什么synchronized的效率非常低。在Java 1.6之后，jvm对锁进行了一个优化，加入了几个较synchronized**更加高效，但使用范围较小**的锁：**偏向锁、轻量级锁、自旋锁**。**偏向锁可以升级到轻量级锁、轻量级锁可以升级到重量级锁**，但升级是**单向**的。

## 偏向锁

**偏向锁**：当第一个试图访问对象锁的线程执行时，如果此时也只有这一个线程对此对象锁进行竞争，不存在其他线程争用，那么此时可采用偏向锁来代替synchronized重量级锁。但在此线程执行过程中，如果发生了其他线程同时竞争此对象锁的情况，JVM会将此线程上的偏向锁消除，将锁升级为轻量级锁。
**偏向锁**的使用条件为**仅有一个线程对一个锁对象进行竞争，并在此线程执行完成之前，没有其他线程与其竞争**。此时使用偏向锁在**不存在竞争**的情况下，完全避免了**不必要的锁重入造成的额外消耗**。当一个线程获取了偏向锁，则会在对象头的MASK WORD中记录当前线程的ID。此后当该线程再次访问同步块时，只需要判断当前对象头中的threadID是否等于当前线程的ID，则无需任何其他操作。

偏向锁的获取与消除：
1、首先访问**synchronized加锁对象的对象头**中MASK WORD中的锁标志位是否为**01（无锁状态或偏向锁状态）**，在接下来判断**偏向锁标志（0还未进入偏向锁，1已经进入偏向锁）**。
2、当Mask Word中的**偏向锁标志**为**1**，则说明此对象已经至少被一个线程**获取过偏向锁**。则此时判断Mask Word中的**thread Id**是否等于**当前线程ID**。若相等，则相当于**偏向锁重入**，可以直接执行同步代码块。若不相等，则使用**CAS操作**去尝试修改**Mask Word中的threadID**；若Mask Word中的**偏向锁标志位**为**0**，此时表明对象还**没有被获取过锁**，此时也会去调用**CAS操作**尝试去修改Mask Word中的**thread ID**。
3、在CAS操作时，如果**成功**，则说明当前**没有**其他线程去**竞争偏向锁**，则在修改完**thread Id**后就可以直接执行同步代码块。当失败的时候，这个时候表明有**线程竞争发生**。此时大致可以分为两种情况：
> **获得对象偏向锁的线程**还**没有执行完成**同步代码块，同时此线程就去**竞争偏向锁**。
> 获得对象偏向锁的线程**已经执行完成同步代码块**或者**不在active状态**或者**还未有线程获取过偏向锁**，此时有**两个或两个以上的线程对偏向锁竞争**。

无论哪种情况的发生，JVM都会对已有的偏向锁进行**消除处理**，并**挂起**当前获取偏向锁的线程。当之前获取偏向锁的线程还在执行状态时，JVM会等待此线程执行到一个**线程safe point**，此时会将此线程挂起，然后再检查此线程的**执行状态**。当该线程已经**执行完成同步代码块**，会将此时的对象头中的偏向锁进行重置为**无锁状态（锁标志位01，偏向锁标志位0）**，然后继续唤醒此**线程继续执行**，而**触发锁竞争的线程**重新回到**第一步去访问mask word**。若此时该线程还在执行同步代码块，JVM将会将此偏向锁升级为**轻量级锁**。

## 轻量级锁

当**两个线程同时争夺一个偏向锁**或者**一个线程去竞争一个还处于活动中的偏向锁时**，此时JVM中会触发偏向锁的升级，将**偏向锁**升级到**轻量级锁**。轻量级锁所提供的优化原理时：在一个线程在获取锁的时候若发生了**竞争**，此时锁已经被另外的线程获取，此时JVM会认为此**获取了锁的线程**会在**很快的时间**内完成**同步代码块的执行，然后释放锁**。此时**JVM**就无需将此**线程挂起**直到等待获取锁的线程**释放锁**，而是**CPU自旋一段时间**。这样就可以省去**线程挂起**以及**线程调度**造成的CPU**不必要的性能消耗**，这比**CPU自旋**的消耗**要大的多**。
轻量级锁只适用于线程**存在竞争**，但**竞争不激烈**的情况下。当CPU**自旋时间超出预计**，或者**自旋期间**又有**其他线程**想要**竞争**此对象锁，这时会将**轻量级锁升级为重量级锁**。

轻量级锁的获取与消除：
在偏向锁准备升级为轻量级锁时，假设此时获取偏向锁的线程为A，另外一个竞争锁的线程为B。此时A在上一步**偏向锁消除**中已经在**SafePoint被挂起**。
1、在**原获取偏向锁的线程A**的**线程栈**中分配一个叫**锁记录的空间**，然后将对象头中的**Mask Word**中的内容拷贝到刚刚创建的线程栈中的**锁记录空间**，接下来**线程A尝试用CAS操作**，**将MASK WORD中的ptr指针指向A线程栈中的锁记录的地址，并将Mask WORD中的锁标志位修改为00（表示轻量级锁）**。此时原获取偏向锁的线程A的偏向锁就**升级为轻量级锁**了。在获取了**轻量级锁后**，JVM会重新唤**醒线程A**，然后继续**从SafePoint开始执行**。
2、在**线程A获取了轻量级锁后**，**线程B也会在其线程栈中创建相同的锁记录空间**，然后**将对象头的MASK WORD内容拷贝进去**。接下来和线程A一样，调用**CAS操作**试图将**MASK WORD的ptr指针记录修改为B线程栈中的锁记录空间地址**。如果操作成功，则说明线程A已经交出来轻量级锁，**线程B获取了轻量级锁**，可以直接执行同步代码块了。若不成功，则**CPU自旋一段时间，并再次进行CAS操作，重复若干次**。若干次之后依旧**没有成功**，则说明竞争比较激烈，**轻量级锁已经不适用**，将**升级为重量级锁**，这里会将**MASK WORD中的锁标志位修改为10（重量级锁）**，然后**挂起当前B线程**。
3、无论那个线程获取了轻量级锁，再其**执行完成同步代码块后**，都会**解锁（消除）轻量级锁**。此时**释放锁的线程**会使用**CAS操作**判断**当前对象头中的MASK WORD中的ptr是否仍指向当前线程的线程栈中的锁记录地址**以及**判断MASK WORD的锁记录标志位是否被修改为10（因为若果发生了轻量级锁的膨胀，这里会再尝试获取锁的线程自旋一段时间后放弃自旋，并修改MASK WORD的值为10）**。如果两者都**没有修改**，则说明没有问题，**锁释放**。若不同，则说明已经切换到**重量级锁了**，然后**将唤醒其他等待重量级锁的线程**，进行**新一轮的竞争**。

## 自旋锁
自旋锁存在的场景是：JVM认为**获取锁的线程**将在**很短的时间内完成同步代码块的执行**，此时**竞争锁的线程**就不需要**立马挂起**，等待获取锁的线程交出锁资源。此时只需要将**竞争锁的线程所在的CPU自旋一段时间（空执行）**，然后**等待锁被释放**。这样就节省了**线程频繁挂**起所引发的**系统上下文切换以及线程调度的消耗**。若自旋一段时间后**仍然不能获取锁**，**线程将放弃自旋，进入阻塞状态**。

## synchronized的优化总结

在偏向锁、轻量级锁、自旋锁以及重量级锁都启用的情况下，当一个线程开始进入到同步代码块执行时：
**检测加锁对象的MASK WORD，判断当前锁的状态**
这里会检测**MASK WORD**的**锁标志位**和**偏向锁标志位**，来查看是否是**无锁状态**，或者偏向锁状态（分为**其他线程获取了偏向锁**、**自身已经获取了锁对象的偏向锁**），或者是**轻量级锁**，或者是**重量级锁**。

**尝试获取加锁对象的偏向锁**
此时对应**无锁状态**或**偏向锁状态**。
当MASK WORD为无锁状态（或者其他线程获取了偏向锁），此时只需要调用CAS操作去修改MASK WORD中的thread Id字段，修改成功后可直接执行同步代码块。若自身已经获取偏向锁，则无需操作，可直接执行同步代码块。若由其他线程获取了偏向锁，此时也会调用CAS操作尝试修改MASK WORD中的thread ID。
在执行CAS操作的时候会分为几种情况：
1、无锁状态，仅有一个线程竞争
2、无锁状态，有两个或两个以上的线程竞争
3、其他线程获取偏向锁、且还在执行同步代码块
4、其他线程获取偏向锁、且执行完成了同步代码块或者被挂起，仅有一个线程竞争
5、其他线程获取偏向锁、且执行完成了同步代码块或者被挂起，有两个或两个以上的线程竞争
此时在情况1和4的时候，CAS会操作成功，情况4会首先消除原偏向锁，然后再新竞争的线程中重新偏向。
2、3、5都会存在CAS操作失败（2、5会一个成功一个失败），此时就会挂起原获取偏向锁的线程，将偏向锁升级为轻量级锁。

**尝试获取轻量级锁或升级为轻量级锁**
此时，一般会有两个线程竞争对象锁，其中一个线程为原持有偏向锁的线程A（此时已经在safe point被挂起），一个为获取偏向锁CAS操作失败的线程B。此时会首先在线程A中的线程栈创建锁记录空间，然后将MASK WORD拷贝进去，接下来调用CAS操作，会尝试修改MASK WORD中ptr指向A线程栈中的锁记录地址。修改成功后会将MASK WORD的锁标记为修改为00（轻量级锁）。此时线程A的偏向锁就升级为轻量级锁。之后就可以唤醒后直接执行同步代码块。此时B线程也会在其线程栈中创建对应的锁记录空间，然后将MASK WORD拷贝进去。然后也尝试调用CAS操作去修改MASK WORD中ptr的指向。若成功则说明已经获取了轻量级锁，可以直接执行同步代码块。若失败，则说明其他线程还在占有轻量级锁，此时线程B所占有的CPU会自旋一段时间，并且每次自选后依旧尝试CAS操作，直到尝试一定时间后，仍获取不了，则将MASK WORD的锁标志位修改为10（表示重量级锁），然后阻塞线程。在某个获取了轻量级锁的线程执行同步代码块完毕后，会进行锁消除或者锁升级。此时会去检测MASK WORD中ptr的指向和锁标记位的值。若锁标记位被修改为10，则说明进入了重量级锁，需要唤醒被阻塞的线程，去进行下一次竞争。

**尝试获取重量级锁或升级为重量级锁**
此时对象头中的MASK WORD已经指向了对象相关的monitor对象的地址。此monitor对象会在对象创建的时候一同创建或者某个线程尝试获取重量级锁的时候创建。
monitor对象中拥有几个比较重要的字段：EntryList、WaitSet、owner、count。
EntryLIst和WaitSet都是用来存放等待获取锁的阻塞线程。
owner指向的是获取了此monitor对象的线程。
count是monitor获取计数器。
EntryList中存放的线程都是首次尝试获取monitor失败的线程。这些线程在被加入EntryList之前，会尝试自旋一段时间，这样做的目的同样是为了减少线程阻塞和调度造成的额外消耗，并增加吞吐量。
当某轮竞争开始，EntryList或waitSet中会选出某个线程去获取monitor，此时owner就会指向此线程，同时count计数加1。
当owenr指向的线程被阻塞，则会被加入到waitSet中，等待下次竞争。

线程都是首次尝试获取monitor时，会首先判断count计数是否为0。如不为0，则说明已经有线程持有了重量级锁，此时就需要继续判断monitor的owner的值。如owner指向当前线程，则属于锁重入，可以直接执行同步代码块。若指向其他线程，则尝试自旋一段时间。
当线程执行完同步代码块，则将会重置monitor中的owner与count的值。然后就可以进行下一次竞争。

偏向锁：适用场景在不存在竞争的情况下，提高同一个线程获取锁的效率。
轻量级锁：适用场景在低烈度的竞争情况下，两个线程竞争同一个对象锁，其中一个采用自旋处理，降低线程阻塞和线程调度造成的过多消耗。
自旋锁：发生竞争时，采用自旋处理，降低线程阻塞和线程调度造成的过多消耗。

## JVM的其他锁优化

**锁消除**：即时编译器JIT在进行编译时，会通过逃逸分析确定变量是否时真正的共享数据，若不是，将会对锁进行消除操作。一般发生于JAVA中自带的同步处理，如String的拼接会自动转化为StringBuffer，此时若这些字符串不会逃逸，则StringBuffer将失去synchronized的意义。
逃逸分析：如果判断一段代码时，在堆上的所有数据都不会逃逸出去，被其他线程所访问到，则可把其当成栈上数据对待，此时可以认为其是线程私有的，也就没有必要加锁了。

**锁膨胀**：原则上我们希望锁的粒度越小越好，只在共享数据的作用域中才进行同步，这样就能使等待的线程尽快拿到锁。但某些情况下，代码中连续的操作中对某个对象进行了加锁，甚至在循环体在，即时没有发生线程竞争，这些频繁的锁获取操作也会造成不必要的性能损失。此时可以将某个synchronized膨胀到整体，执行时只需要加一次锁就可以保证线程安全。



