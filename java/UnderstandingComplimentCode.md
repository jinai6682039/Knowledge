# 补码的真实理解

在很多树上都是直接说负数的补码是其源码除符号位按位取反，然后末尾加一。这种说法只是说明了补码的取值操作，并没有说明为什么这样操作和这样操作的依据。

这里说到补码的来源，就要提到取模运算了。
这里假设n、m两个整数，n<m。
当n % m = n + (任意正整数 * m) % m是恒成立的。这里就引出了一个**同余**的概念。
同余：若a、b两个整数，若他们除以整数m所获得的余数相等，则a、b对m同余。记作a≡b (mod m)
这时我们可以看下，负数是怎么取模的:
x mod y = x - y [ x / y ]
解释为x mod y等于 x 减去 y 乘上（x / y）的商的向下取整。
-3 mod 4 = -3 - （ 4 * [-3 / 4])
				= -3 - ( 4 * -1)
				= 1
1 mod 4 = 1

-2 mod 4 = 2
2 mod 4 = 2

-1 mod 4 = 3
3 mod 4 = 3

这里可以看到-3和1同余，-2与2同余， -1与3同余。
同余有几个性质：反身性、对称性、传递性、同余式相加以及同余式相乘。
a ≡ a (mod m)
a ≡ b (mod m) =>b ≡ a (mod m)
a ≡ b (mod m) b ≡ c (mod m) => a≡c (mod m)
a ≡ b (mod m) c ≡ d (mod m) => a + c ≡ b + d (mod m) 
a ≡ b (mod m) c ≡ d (mod m) => a * c ≡ b * d (mod m) 
这五条性质的公式表示。

3 ≡ 3 (mod 4)
-2 ≡ 2 (mod 4)
则有3 - 2 ≡ 3 + 2 (mod 4) 

这里我们就为-2找到了一个与其同余的正整数。这里再将数值扩大到8位二进制（第一位为符号位）。
-1 mod 256 = 255
255 mod 256 = 255
-1 ≡ 255 (mod 256) 
此时-1与255同余。而计算器使用的加法器，本质上也就是个同余运算器，在8bit模式下，只能表示2^8 -1 个数，此时表示负数的话，可以直接取与当前负数同余的正整数来代替。此时计算机为了方便运算，就会在计算时使用255代替-1（仅8bit模式下）。而又为了能够表示正负数，所以根据首位来表示数的正负，也就形成了一半表示正数一半表示负数。
那么上面归纳的补码公式是怎么得到的呢？在8bit模式下首先可以得到：
x + ~x(按位取反操作) ≡ 255 (mod 256) 
x + ~x(按位取反操作) + 1≡ 0 (mod 256) 
-x ≡   ~x(按位取反操作) + 1 (mod 256) 
这也就是 为什么补码才有其原码按位取反再加1的操作了。而反码的存在就是将上述三个式子的第一个的255也看成了-0的存在来推导的。

## 总结
补码（反码）的存在是为了**简化计算机的设计**，为了能够将**减法**转化为**加法**操作，使计算机只需要一个**加法器**就能够完成所有的加减乘除计算。
而计算器中的加法器的运算其实就是进行**同余运算**，在32位机器中，如果不考虑符号位计算，会存在下面这几个推导公式，此时x > 0：
x + ~x(按位取反操作) ≡ (2^32 -1) (mod 2 ^ 32)
x + ~x(按位取反操作) + 1 ≡ 0 (mod 2 ^ 32)
-x ≡   ~x(按位取反操作) + 1 (mod 2 ^ 32) 
这里就可以推导出在同余运算下，**-x与x的等效替代计算的方法**。也就是我们的补码计算公式：按位取反，再末尾加1。这里用通俗一点的话概况，也就是**对于负数在计算机中的表示，其实就是用其在同余运算下的等效正整数来表示**，正好这些正整数（不考虑符号位）的首位都为1，也就用第一位作为符号位。这也就推到了为什么在32bit机器下的补码的表示范围[-2 ^ 31, 2 ^ 31 -1]的数表示范围（对于除了符号位为1，其他位都为0的特殊值，计算机将其表示为所能表示的最小负数）。




				